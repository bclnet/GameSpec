using GameSpec.Formats;
using GameSpec.Meta;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace GameSpec.Origin.Formats.UO
{
    public unsafe class Binary_CalibrationInfo : IHaveMetaInfo
    {
        public static Task<object> Factory(BinaryReader r, FileSource f, PakFile s) => Task.FromResult((object)new Binary_CalibrationInfo(r.ToStream()));

        #region Records

        public class Record
        {
            public readonly byte[] Mask;
            public readonly byte[] Vals;
            public readonly byte[] DetX;
            public readonly byte[] DetY;
            public readonly byte[] DetZ;
            public readonly byte[] DetF;

            public Record(byte[] mask, byte[] vals, byte[] detx, byte[] dety, byte[] detz, byte[] detf)
            {
                Mask = mask;
                Vals = vals;
                DetX = detx;
                DetY = dety;
                DetZ = detz;
                DetF = detf;
            }
        }

        static readonly List<Record> Records = new List<Record>();

        static Record[] DefaultRecords { get; set; } = {
            new Record(
                //Post 7.0.4.0 (Andreew)
                new byte[]
                {
                    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
                    0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF
                },
                new byte[]
                {
                    0xFF, 0xD0, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x11, 0x8B,
                    0x82, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x5B, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEC
                },
                new byte[]{ 0x22, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x0C }, //x
                new byte[]{ 0x22, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x08 }, //y
                new byte[]{ 0x22, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x04 }, //z
                new byte[]{ 0x22, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x10 }),//f
            new Record(
                /* (arul) 6.0.9.x+ : Calibrates both  */
                new byte[]
                {
                    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
                    0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF
                },
                new byte[]
                {
                    0xFF, 0xD0, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x11, 0x8B,
                    0x82, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x5E, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x0D
                },
                new byte[]{ 0x1F, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x0C },
                new byte[]{ 0x1F, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x08 },
                new byte[]{ 0x1F, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x04 },
                new byte[]{ 0x1F, 0x04, 0xFF, 0xFF, 0xFF, 0x04, 0x10 }),
            new Record(
                /* Facet */
                new byte[]
                {
                    0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
                },
                new byte[]
                {
                    0xA0, 0x00, 0x00, 0x00, 0x00, 0x84, 0xC0, 0x0F, 0x85, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x0D
                },
                Array.Empty<byte>(),
                Array.Empty<byte>(),
                Array.Empty<byte>(),
                new byte[]{ 0x01, 0x04, 0xFF, 0xFF, 0xFF, 0x01 }
            ),
            new Record(
                /* Location */
                new byte[]
                {
                    0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00,
                    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00
                },
                new byte[]
                {
                    0x8B, 0x15, 0x00, 0x00, 0x00, 0x00, 0x83, 0xC4, 0x10, 0x66, 0x89, 0x5A, 0x00, 0xA1, 0x00, 0x00,
                    0x00, 0x00, 0x66, 0x89, 0x78, 0x00, 0x8B, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x66, 0x89, 0x71, 0x00
                },
                new byte[]{ 0x02, 0x04, 0x04, 0x0C, 0x01, 0x02 },
                new byte[]{ 0x0E, 0x04, 0x04, 0x15, 0x01, 0x02 },
                new byte[]{ 0x18, 0x04, 0x04, 0x1F, 0x01, 0x02 },
                Array.Empty<byte>()
            ),
            new Record(
                /* UO3D Only, calibrates both */
                new byte[]
                {
                    0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF,
                    0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
                },
                new byte[]
                {
                    0xA1, 0x00, 0x00, 0x00, 0x00, 0x68, 0x40, 0x2E, 0x04, 0x01, 0x0F, 0xBF, 0x50, 0x00, 0x0F, 0xBF,
                    0x48, 0x00, 0x52, 0x51, 0x0F, 0xBF, 0x50, 0x00, 0x52, 0x8D, 0x85, 0xE4, 0xFD, 0xFF, 0xFF, 0x68,
                    0x00, 0x00, 0x00, 0x00, 0x50, 0xE8, 0x07, 0x44, 0x10, 0x00, 0x8A, 0x0D, 0x00, 0x00, 0x00, 0x00
                },
                new byte[] { 0x01, 0x04, 0x04, 0x17, 0x01, 0x02 },
                new byte[] { 0x01, 0x04, 0x04, 0x11, 0x01, 0x02 },
                new byte[] { 0x01, 0x04, 0x04, 0x0D, 0x01, 0x02 },
                new byte[] { 0x2C, 0x04, 0xFF, 0xFF, 0xFF, 0x01 }
            )
        };

        #endregion

        // file: calibration.cfg
        public Binary_CalibrationInfo(StreamReader r)
        {
            while (r.ReadLine() is { } line)
            {
                line = line.Trim();
                if (!line.Equals("Begin", StringComparison.OrdinalIgnoreCase)) continue;

                byte[] mask, vals, detx, dety, detz, detf;
                if ((mask = ReadBytes(r)) == null) continue;
                if ((vals = ReadBytes(r)) == null) continue;
                if ((detx = ReadBytes(r)) == null) continue;
                if ((dety = ReadBytes(r)) == null) continue;
                if ((detz = ReadBytes(r)) == null) continue;
                if ((detf = ReadBytes(r)) == null) continue;
                Records.Add(new Record(mask, vals, detx, dety, detz, detf));
            }
            Records.AddRange(DefaultRecords);
        }

        static byte[] ReadBytes(TextReader r)
        {
            var line = r.ReadLine();
            if (line == null) return null;

            var b = new byte[(line.Length + 2) / 3];
            var index = 0;
            for (var i = 0; (i + 1) < line.Length; i += 3)
            {
                var ch = line[i + 0];
                var cl = line[i + 1];

                if (ch >= '0' && ch <= '9') ch -= '0';
                else if (ch >= 'a' && ch <= 'f') ch -= (char)('a' - 10);
                else if (ch >= 'A' && ch <= 'F') ch -= (char)('A' - 10);
                else return null;

                if (cl >= '0' && cl <= '9') cl -= '0';
                else if (cl >= 'a' && cl <= 'f') cl -= (char)('a' - 10);
                else if (cl >= 'A' && cl <= 'F') cl -= (char)('A' - 10);
                else return null;

                b[index++] = (byte)((ch << 4) | cl);
            }
            return b;
        }

        // IHaveMetaInfo
        List<MetaInfo> IHaveMetaInfo.GetInfoNodes(MetaManager resource, FileSource file, object tag)
        {
            var nodes = new List<MetaInfo> {
                new MetaInfo(null, new MetaContent { Type = "Text", Name = Path.GetFileName(file.Path), Value = "Body config" }),
                new MetaInfo("Body", items: new List<MetaInfo> {
                    new MetaInfo($"Count: {Records.Count}"),
                })
            };
            return nodes;
        }
    }
}
